(uiop:define-package #:staticl/filter
  (:use #:cl)
  (:import-from #:staticl/pipeline)
  (:import-from #:serapeum
                #:soft-list-of
                #:->
                #:directory-pathname)
  (:import-from #:staticl/site
                #:site)
  (:import-from #:staticl/content
                #:path-matches-p
                #:has-tag-p
                #:content)
  (:import-from #:staticl/current-root
                #:current-root)
  (:import-from #:staticl/utils
                #:comma-split)
  (:export #:filter
           #:filter-fn
           #:pipeline-items))
(in-package #:staticl/filter)


(deftype filter-predicate ()
  '(function (content)
    (values boolean &optional)))


(defclass filter ()
  ((filter-fn :initarg :filter-fn
              :type filter-predicate
              :reader filter-fn)
   (pipeline :initarg :pipeline
             :type list
             :reader pipeline-items))
  (:default-initargs
   :pipeline nil))


(defmacro filter ((&key path tags invert) &body pipeline)
  "Filters input content objects and processes them using pipeline items given as a body.

   Arguments:

   - PATH: result will contain only items read from the given path.
   - TAGS: result will contain only items having all given tags.
   - INVERT: inverts effect of the filter.
   - PIPELINE: any number of function calls returning pipeline nodes.

   **Note:** Right now, all new items generated by PIPELINE given to the FILTER macro
   are added to the toplevel list and stay invisible to the sebsequent pipeline nodes.
   The same applicable to content deletion."
  
  (let (rules)
    (when path
      (push `(path-matches-p item (merge-pathnames (uiop:ensure-directory-pathname ,path)
                                                   (current-root)))
            rules))
    
    (when tags
      (loop for tag-name in (etypecase tags
                              (string (comma-split tags))
                              (list tags))
            do (push `(has-tag-p item ,tag-name)
                     rules)))

    (setf rules
          (if invert
              `(not (and ,@rules))
              `(and ,@rules)))
    
    
    `(flet ((filter-fn (item)
              ,rules))
       (make-instance 'filter
                      :filter-fn #'filter-fn
                      :pipeline (list ,@pipeline)))))


(-> filter-items ((soft-list-of content) filter)
    (soft-list-of content))

(defun filter-items (content-items filter-node)
  (remove-if-not (filter-fn filter-node)
                 content-items))


(defmethod staticl/pipeline:process-items ((site site) (node filter) content-items)
  (let ((filtered (filter-items content-items node)))
    (loop for subnode in (pipeline-items node)
          do (staticl/pipeline:process-items site subnode filtered))))
